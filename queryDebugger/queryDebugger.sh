#!/usr/local/bin/node

// works best if you set up ssh keys for logging in.
// replace this next line with actual credentials
var mysqlCmd = "ssh tfeiler@ventnor.its.carleton.edu 'mysql -ureason -pica00rus cms_slote";

// Ex: "cat somefile.sql | queryDebugger.sh"
// more realistically - I've set up a function in
// Vim called ExplainReasonQuery that takes a line from the buffer, pipes it to this script,
// and returns it back to Vim, nicely formatted

//basic idea - takes a bunch of unformatted SQL generated by Reason entity/db selectors like:
// SELECT entity.id, __entity__.id AS page_id FROM entity AS entity, relationship AS relationship, relationship AS relationship2, entity AS __entity__ WHERE entity.state = "Live" AND `entity`.`type` = "153392" AND relationship.entity_b = entity.id AND relationship.entity    _a = 58093 AND relationship.type = 398 AND __entity__.id = relationship2.entity_a AND entity.id = relationship2.entity_b AND relationship2.type = 313 ORDER BY entity.id;
// 
// and :
// 1. format it in a more readable fashion with SELECT/FROM/etc. on separate lines, with indentation
// 2. attempts to look up particular ids in various ways to add helpful comments to the sql
// console.log("queryDebugger starting work...");

try {
	var execSync = require('exec-sync');
}catch (e) {
	console.log("Error loading dependencies; did you run 'npm install'?");
}

function debug(s) {
	//console.log(s);
}

debug("Processing...");

var stdin = process.openStdin();

var data = "";

stdin.on('data', function(chunk) {
	data += chunk;
});

stdin.on('end', function() {
	var lastChar = data.substr(data.length-2, 1);
	if (lastChar != ";") { data = data.substr(0, data.length-1) + ";"; }
	formatSql(data);
});

function formatSql(data) {
	var re = /select\s*(.*)from\s*(.*)where\s*(.*)order\s*by\s*([^;]*);?/i
	var match = re.exec(data);
	if (match == null) {
		re = /select\s*(.*)from\s*(.*)where\s*([^;]*);?/i;
		match = re.exec(data);
	}

	var selClause = match[1];
	var fromClause = match[2];
	var whereClause = match[3];
	var orderbyClause = match[4];

	var output = chunkAndEcho("SELECT", selClause, /,\s*/, ",");
	output += chunkAndEcho("FROM", fromClause, /,\s*/, ",");
	output += chunkAndEcho("WHERE", whereClause, /\s*AND\s*/, " AND");

	if (orderbyClause != undefined) {
		output += chunkAndEcho("ORDER BY", orderbyClause, /,\s*/, ",");
	}
	// output = output.replace(/\n$/, ";");
	output += ";";
	console.log(output);
}

function chunkAndEcho(clauseTitle, clause, separatorRegex, separator) {
	var rv = clauseTitle + "\n";
	var chunks = clause.split(separatorRegex);
	for (var i = 0 ; i < chunks.length ; i++) {
		var chunk = chunks[i];

		var details = lookupDetails(chunk, 1);
		rv += "\t" + chunk + (i < chunks.length - 1 ? separator : "") + details + "\n";
	}
	return rv;
}

function lookupDetails(chunk, passAttempt) {
	var rv = "";

	var re = undefined;
	var match = undefined;

	var q = "SELECT name FROM entity WHERE id = ";
	var postQ = "";
	if (passAttempt == 1) {
		re = /entity.*type.*=\s*"?(\d+)"?.*/i;
		match = re.exec(chunk);
	} else if (passAttempt == 2) {
		re = /relationship.*\.entity.*=\s*"?(\d+)"?.*/i;
		match = re.exec(chunk);
	} else if (passAttempt == 3) {
		q = "SELECT name FROM allowable_relationship WHERE id = ";
		re = /relationship.*\.type.*=\s*"?(\d+)"?.*/i;
		match = re.exec(chunk);
	} else if (passAttempt == 4) {
		re = /entity.*id\s*in\s*\((.*)\).*/i;
		match = re.exec(chunk);
		q = "SELECT group_concat(id, \\\"=\\\", name SEPARATOR \\\", \\\") FROM entity WHERE id IN (";
		postQ = ")";
	} else {
		// rv = "\t\t--giving up on pass [" + passAttempt + "]";
		return rv;
	}

	if (match != undefined) {
		var id = match[1];
		debug("chunk [" + chunk + "], pass [" + passAttempt + "] yields id [" + id + "]");
		cmd = mysqlCmd + " -e \"" + q + id + postQ + "\"'";
		debug("cmd is [" + cmd + "]");

		cmdResults = execSync(cmd);
		var lines = cmdResults.split("\n");
		debug("results are [" + cmdResults + "]");

		if (lines.length == 2) {
			rv = " -- (" + lines[1] + ")";
		} else {
			rv = lookupDetails(chunk, passAttempt+1);
		}
	} else {
		rv = lookupDetails(chunk, passAttempt+1);
	}

	return rv;
}
